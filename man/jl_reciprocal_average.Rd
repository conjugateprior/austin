% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jl.R
\name{jl_reciprocal_average}
\alias{jl_reciprocal_average}
\title{Compute Positions via Reciprocal Averaging}
\usage{
jl_reciprocal_average(
  x,
  dir = c(1, nrow(x)),
  tol = 0.001,
  verbose = FALSE,
  iter.max = 50
)
}
\arguments{
\item{x}{a matrix}

\item{dir}{Require that document positions are such that dir[1] < dir[2]}

\item{tol}{the largest position difference small enough to stop iterating}

\item{verbose}{whether to report iterations and differences}

\item{iter.max}{maximum number of iterations regardless of tol}
}
\value{
a list of theta and beta estimates
}
\description{
This function runs the simplest form of reciprocal averaging and produces
estaimted theta (document) and beta (word) positions. Theta is mean zero 
and unit variance. Beta is mean zero.
}
\details{
Why would you use this function? Perhaps because it is like doing 
1-dimensional correspondence analysis but never computes a full SVD
and never stores more than one copy of the input data, which can be 
sparse. Hence it saves memory. 

Why would you not use this function? Because it trades space for time. 
It's usually quicker to run SVD on the (dense) residuals matrixes as 
regular correspondence is defined as doing. Also this function will not get 
recover than one set of document and feature positions.
}
\examples{

data(LBG2003)
lbg_dfm <- jl_dfm(LBG2003, rownames_from = "doc_id")
res <- jl_reciprocal_average(lbg_dfm)
res$theta # the six document scores
}
